import {
//   createAsyncThunk,
  createSlice,
  PayloadAction,
} from "@reduxjs/toolkit";

import {
  RootState,
  //   AppThunk,
} from "../store";

// import { toast } from "react-toastify";
import { socket } from "../../config/config.socket";
import { IConversation, IPMessage } from "../../interfaces";

// const position = {
//   position: toast.POSITION.BOTTOM_RIGHT,
// };

export interface UserSocket {
  userId: string;
  socketId: string;
}

export interface SocketState {
  addUserEmited: boolean;
  connectedUsers: UserSocket[];
  lastMessagesSent: (
    | {
        messageId: string;
        receiversIds: string[];
        senderId: string;
        conversationId: string;
      }
    | undefined
  )[];
  lastMessagesReceived: (
    | {
        messageId: string;
        receiversIds: string[];
        senderId: string;
        conversationId: string;
        notcheckedMessagesInThisConversationNumber: number;
      }
    | undefined
  )[];
  notCheckedFriendRequestsNumber: number;

  rooms: any[];
  isFetching: boolean;
  error: any;
}

const initialState: SocketState = {
  addUserEmited: false,
  connectedUsers: [],
  lastMessagesSent: [],
  lastMessagesReceived: [],
  notCheckedFriendRequestsNumber: 0,

  rooms: [],
  isFetching: false,
  error: false,
};

// The function below is called a thunk and allows us to perform async logic. It
// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This
// will call the thunk with the `dispatch` function as the first argument. Async
// code can then be executed and other actions can be dispatched. Thunks are
// typically used to make async requests.

export const socketSlice = createSlice({
  name: "socket",
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    // Redux Toolkit allows us to write "mutating" logic in reducers. It
    // doesn't actually mutate the state because it uses the Immer library,
    // which detects changes to a "draft state" and produces a brand new
    // immutable state based off those changes
    // Use the PayloadAction type to declare the contents of `action.payload`
    socketAddUser: (
      state,
      action: PayloadAction<string>,
    ) => {
      const currentUserId = action.payload;
      socket.emit("addUser", currentUserId);
      state.addUserEmited = true;
    },
    setConnectedUsers: (
      state,
      action: PayloadAction<UserSocket[]>,
    ) => {
      state.connectedUsers = action.payload;
    },
    setNotCheckedFriendsRequestNumber: (
      state,
      action: PayloadAction<number>,
    ) => {
      state.notCheckedFriendRequestsNumber = action.payload;
    },
    incrementFriendsRequestsNumber: (state) => {
      state.notCheckedFriendRequestsNumber += 1;
    },
    socketSendMessage: (
      state,
      action: PayloadAction<{
        conversation: IConversation;
        message: IPMessage;
        currentUserId: string;
      }>,
    ) => {
      const { conversation, message, currentUserId } =
        action.payload;
      const receiversIds: string[] =
        conversation?.membersId!.filter(
          (mId: string) => mId !== currentUserId,
        );

      for (const receiverId of receiversIds!) {
        socket?.emit("sendMessage", {
          receiverId,
          conversation,
          message,
        });
      }

    //   const conversationId = conversation._id!;
    //   const messageId = message._id!;
    //   const senderId = message.senderId._id!;

    //   let lastMessageSent:
    //     | {
    //         messageId: string;
    //         receiversIds: string[];
    //         senderId: string;
    //         conversationId: string;
    //       }
    //     | undefined;

    //   if (!!state.lastMessagesSent?.length) {
    //     lastMessageSent = state.lastMessagesSent.find(
    //       (lm) => (lm!.conversationId = conversation._id!),
    //     );

    //     if (!!lastMessageSent) {
    //       state.lastMessagesSent =
    //         state.lastMessagesSent.map((l) => {
    //           if (l?.conversationId === conversationId) {
    //             return {
    //               conversationId,
    //               messageId,
    //               receiversIds,
    //               senderId,
    //             };
    //           } else return l;
    //         });
    //     } else {
    //       state.lastMessagesSent = [
    //         {
    //           conversationId,
    //           messageId,
    //           receiversIds,
    //           senderId,
    //         },
    //         ...state.lastMessagesSent,
    //       ];
    //     }
    //   } else {
    //     state.lastMessagesSent = [
    //       {
    //         conversationId,
    //         messageId,
    //         receiversIds,
    //         senderId,
    //       },
    //     ];
    //   }
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
});

export const {
  socketAddUser,
  setConnectedUsers,
  setNotCheckedFriendsRequestNumber,
  incrementFriendsRequestsNumber,
  socketSendMessage,
} = socketSlice.actions;

// The function below is called a selector and allows us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`

export const selectConnectedUsers = (state: RootState) =>
  state.socket.connectedUsers;

// We can also write thunks by hand, which may contain both sync and async logic.
// Here's an example of conditionally dispatching actions based on current state.

export default socketSlice.reducer;
